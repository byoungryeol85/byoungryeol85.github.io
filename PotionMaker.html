<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>í¬ì…˜ ë©”ì´ì»¤</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 16px 8px;
    user-select: none; /* í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ë°©ì§€ */
  }

  .game-wrapper {
    width: min(90vw, 420px);
    max-height: 75vh; /* ì„¸ë¡œ í™”ë©´ì˜ 3/4 ì •ë„ ëŠë‚Œ */
    display: flex;
    flex-direction: column;
    gap: 8px;
    position: relative;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    font-size: 14px;
    margin-bottom: 4px;
  }

  .title {
    font-weight: 700;
    font-size: 15px;
  }

  .stats {
    display: flex;
    gap: 12px;
    font-size: 13px;
    align-items: baseline;
  }

  .stat-group {
    display: flex;
    gap: 4px;
    align-items: baseline;
  }

  .stat-label {
    color: #555;
    font-size: 12px;
  }

  .stat-value {
    font-weight: 800;
    font-size: 18px; /* í¬ê²Œ */
  }

  #time.time-danger {
    color: #d32f2f;
  }

  #grid {
    position: relative; /* ë“œë˜ê·¸ ë°•ìŠ¤ ê¸°ì¤€ */
    flex: 1;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 4px;
    background: #e5e5e5;
    padding: 4px;
    border-radius: 12px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.08);
    touch-action: none; /* ë¸Œë¼ìš°ì € ê¸°ë³¸ ìŠ¤í¬ë¡¤ ì œìŠ¤ì²˜ ë°©ì§€ */
  }

  .cell {
    position: relative;
    aspect-ratio: 1 / 1;
    border-radius: 10px;
    background: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    touch-action: none;
    overflow: visible;
    transition: transform 0.08s ease, box-shadow 0.08s ease,
                background 0.15s ease, opacity 0.15s ease;
  }

  /* ë™ê·¸ë€ ë¬¼ì•½ë³‘ (ìœ ë¦¬) */
  .cell::before {
    content: "";
    position: absolute;
    width: 72%;
    height: 72%;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.85), rgba(255,245,245,0.9));
    border: 2px solid rgba(255, 143, 143, 0.6);
    box-shadow:
      0 2px 4px rgba(0,0,0,0.08),
      0 0 0 1px rgba(255,255,255,0.8) inset;
    z-index: 1;
  }

  /* ë¬¼ì•½ ì•¡ì²´ â€“ ì€ì€í•œ ë¹¨ê°„ìƒ‰, ê°„ì ‘ í‘œí˜„ */
  .cell::after {
    content: "";
    position: absolute;
    left: 50%;
    bottom: 14%;
    width: 58%;
    height: var(--fill, 25%);
    transform: translateX(-50%);
    border-radius: 999px 999px 40% 40%;
    background: linear-gradient(
      to top,
      rgba(255, 138, 128, 0.45),
      rgba(255, 205, 210, 0.3)
    );
    box-shadow: 0 -2px 3px rgba(255, 255, 255, 0.6) inset;
    z-index: 2;
    transition: height 0.15s ease;
  }

  .cell span.value {
    position: relative;
    z-index: 3;
    color: #4e342e;
    font-size: 18px;
    font-weight: 800;
    text-shadow:
      0 1px 2px rgba(255,255,255,0.9),
      0 -1px 1px rgba(0,0,0,0.05);
  }

  .cell.selected::before {
    box-shadow:
      0 0 0 2px rgba(255, 183, 77, 0.8),
      0 2px 4px rgba(0,0,0,0.1);
  }

  .cell.cleared {
    opacity: 0.35;
    cursor: default;
  }
  .cell.cleared::before,
  .cell.cleared::after {
    filter: grayscale(60%);
    opacity: 0.5;
  }
  .cell.cleared span.value {
    opacity: 0;
  }

  .cell.highlight {
    animation: blink 0.2s ease-in-out 2;
  }

  @keyframes blink {
    0% { transform: scale(1); }
    50% { transform: scale(1.04); }
    100% { transform: scale(1); }
  }

  .controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 6px;
    gap: 8px;
  }

  .message {
    flex: 1;
    font-size: 12px;
    color: #555;
    min-height: 1.2em;
  }

  button {
    padding: 6px 14px;
    border-radius: 999px;
    border: none;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    background: #ff7043;
    color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    touch-action: manipulation;
  }

  button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  }

  /* ê³µí†µ ì˜¤ë²„ë ˆì´ */
  .overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.35);
    z-index: 999;
  }

  .overlay.hidden {
    display: none;
  }

  .overlay-box {
    background: #ffffff;
    border-radius: 18px;
    padding: 20px 18px 16px;
    min-width: min(80vw, 320px);
    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    text-align: center;
  }

  .overlay-title {
    font-size: 18px;
    font-weight: 800;
    margin-bottom: 10px;
  }

  .overlay-score {
    font-size: 16px;
    margin-bottom: 6px;
  }

  .overlay-best {
    font-size: 14px;
    color: #555;
    margin-bottom: 14px;
  }

  .overlay-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
  }

  .overlay-buttons button {
    font-size: 13px;
    padding: 7px 16px;
  }

  .overlay-text {
    font-size: 14px;
    color: #444;
    margin-bottom: 14px;
    line-height: 1.5;
  }

  .badge-new {
    display: inline-block;
    margin-left: 6px;
    padding: 2px 6px;
    border-radius: 999px;
    background: #ffca28;
    font-size: 11px;
    font-weight: 700;
    color: #5d4037;
  }

  /* ë“œë˜ê·¸ ë°•ìŠ¤ (ìœˆë„ìš° ì„ íƒ ë°•ìŠ¤ ëŠë‚Œ) */
  .drag-box {
    position: absolute;
    border: 2px dashed rgba(255, 183, 77, 0.95);
    background: rgba(255, 224, 178, 0.25);
    border-radius: 10px;
    pointer-events: none;
    z-index: 10;
  }
</style>
</head>
<body>
<div class="game-wrapper">
  <div class="header">
    <div class="title">ğŸ§ª í¬ì…˜ ë©”ì´ì»¤</div>
    <div class="stats">
      <div class="stat-group">
        <span class="stat-label">TIME</span>
        <span id="time" class="stat-value">90</span>
      </div>
      <div class="stat-group">
        <span class="stat-label">SUM</span>
        <span id="sum" class="stat-value">0</span>
      </div>
      <div class="stat-group">
        <span class="stat-label">SCORE</span>
        <span id="score" class="stat-value">0</span>
      </div>
    </div>
  </div>

  <div id="grid"></div>

  <div class="controls">
    <div id="message" class="message"></div>
    <button id="resetBtn">ë‹¤ì‹œ</button>
  </div>
</div>

<!-- ì‹œì‘ íŒì—… -->
<div id="startOverlay" class="overlay">
  <div class="overlay-box">
    <div class="overlay-title">í¬ì…˜ ë©”ì´ì»¤</div>
    <div class="overlay-text">
      ì–´ì§€ëŸ½í˜€ì§„ í¬ì…˜ë“¤ì„ ì •ë¦¬í•  ì‹œê°„ì´ì—ìš”!<br>
      í¬ì…˜ì„ ë“œë˜ê·¸ í•´ì„œ ìš©ëŸ‰ 10ì§œë¦¬ í¬ì…˜ì„ ë§Œë“¤ë©´ ì„±ê³µ!<br>
      90ì´ˆ ë™ì•ˆ ìµœëŒ€í•œ ë§ì´ ë§Œë“¤ì–´ë³´ì„¸ìš”!
    </div>
    <div class="overlay-buttons">
      <button id="startBtn">ê²Œì„ ì‹œì‘</button>
    </div>
  </div>
</div>

<!-- ì‹œê°„ ì¢…ë£Œ íŒì—… -->
<div id="overlay" class="overlay hidden">
  <div class="overlay-box">
    <div class="overlay-title">â° ì‹œê°„ ì¢…ë£Œ!</div>
    <div id="overlayCurrent" class="overlay-score"></div>
    <div id="overlayBest" class="overlay-best"></div>
    <div class="overlay-buttons">
      <button id="overlayRestart">ë‹¤ì‹œ í”Œë ˆì´</button>
    </div>
  </div>
</div>

<script>
  const COLS = 8;
  const ROWS = 10;
  const gridEl = document.getElementById("grid");
  const sumEl = document.getElementById("sum");
  const scoreEl = document.getElementById("score");
  const messageEl = document.getElementById("message");
  const resetBtn = document.getElementById("resetBtn");
  const timeEl = document.getElementById("time");

  const overlayEl = document.getElementById("overlay");
  const overlayCurrentEl = document.getElementById("overlayCurrent");
  const overlayBestEl = document.getElementById("overlayBest");
  const overlayRestartBtn = document.getElementById("overlayRestart");

  const startOverlayEl = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");

  const BEST_KEY = "apple_drag_rect_best_score_v1";

  let grid = [];
  let selected = [];
  let currentSum = 0;
  let score = 0;

  let isDragging = false;

  let timeLeft = 90;
  let timerId = null;
  let gameOver = false;
  let bestScore = 0;

  // ë“œë˜ê·¸ ë°•ìŠ¤ ê´€ë ¨
  let dragBoxEl = null;
  let dragStartPxX = 0;
  let dragStartPxY = 0;
  let dragEndPxX = 0;
  let dragEndPxY = 0;

  function ensureDragBox() {
    if (!dragBoxEl) {
      dragBoxEl = document.createElement("div");
      dragBoxEl.className = "drag-box";
      dragBoxEl.style.display = "none";
      gridEl.appendChild(dragBoxEl);
    } else if (!gridEl.contains(dragBoxEl)) {
      gridEl.appendChild(dragBoxEl);
    }
  }

  function showDragBox(x1, y1, x2, y2) {
    ensureDragBox();
    const left = Math.min(x1, x2);
    const top = Math.min(y1, y2);
    const width = Math.abs(x2 - x1);
    const height = Math.abs(y2 - y1);
    dragBoxEl.style.display = "block";
    dragBoxEl.style.left = left + "px";
    dragBoxEl.style.top = top + "px";
    dragBoxEl.style.width = width + "px";
    dragBoxEl.style.height = height + "px";
  }

  function hideDragBox() {
    if (dragBoxEl) {
      dragBoxEl.style.display = "none";
    }
  }

  function loadBestScore() {
    const saved = localStorage.getItem(BEST_KEY);
    if (saved !== null) {
      const val = Number(saved);
      if (!Number.isNaN(val)) bestScore = val;
    }
  }

  function saveBestScore() {
    localStorage.setItem(BEST_KEY, String(bestScore));
  }

  function randValue() {
    // 1~9, 1~5ê°€ ì¡°ê¸ˆ ë” ì˜ ë‚˜ì˜¤ê²Œ
    const weights = [1,2,3,4,5,6,7,8,9,1,2,3,4,5];
    return weights[Math.floor(Math.random() * weights.length)];
  }

  function createGridData() {
    grid = [];
    for (let y = 0; y < ROWS; y++) {
      const row = [];
      for (let x = 0; x < COLS; x++) {
        row.push({
          x,
          y,
          value: randValue(),
          cleared: false,
          el: null
        });
      }
      grid.push(row);
    }
  }

  function renderGrid() {
    gridEl.innerHTML = "";
    grid.forEach(row => {
      row.forEach(cellData => {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.x = cellData.x;
        cell.dataset.y = cellData.y;

        // í¬ì…˜ ë†’ì´: ê°’ 1~9 â†’ 20~70% ì •ë„ (ì€ì€í•˜ê²Œ)
        const fillPercent = 20 + (cellData.value - 1) * (50 / 8); // 20~70%
        cell.style.setProperty("--fill", fillPercent + "%");

        const span = document.createElement("span");
        span.className = "value";
        span.textContent = cellData.value;
        cell.appendChild(span);

        cellData.el = cell;
        gridEl.appendChild(cell);
      });
    });
    ensureDragBox();
  }

  function setMessage(text) {
    messageEl.textContent = text || "";
  }

  function updateSum() {
    currentSum = selected.reduce((acc, c) => acc + c.value, 0);
    sumEl.textContent = currentSum;
  }

  function clearSelectionVisual() {
    selected.forEach(c => {
      if (c.el && !c.cleared) {
        c.el.classList.remove("selected");
      }
    });
    selected = [];
    currentSum = 0;
    sumEl.textContent = "0";
  }

  // ë“œë˜ê·¸ ë°•ìŠ¤ í”½ì…€ ê¸°ì¤€ìœ¼ë¡œ ì–´ë–¤ ì…€ë“¤ì´ ë“¤ì–´ì™”ëŠ”ì§€ ê³„ì‚°
  function applyRectSelectionByPixels() {
    clearSelectionVisual();
    const rect = gridEl.getBoundingClientRect();

    const minX = Math.min(dragStartPxX, dragEndPxX);
    const maxX = Math.max(dragStartPxX, dragEndPxX);
    const minY = Math.min(dragStartPxY, dragEndPxY);
    const maxY = Math.max(dragStartPxY, dragEndPxY);

    grid.forEach(row => {
      row.forEach(cellData => {
        if (cellData.cleared || !cellData.el) return;
        const cr = cellData.el.getBoundingClientRect();
        const centerX = cr.left - rect.left + cr.width / 2;
        const centerY = cr.top - rect.top + cr.height / 2;

        if (centerX >= minX && centerX <= maxX && centerY >= minY && centerY <= maxY) {
          selected.push(cellData);
          cellData.el.classList.add("selected");
        }
      });
    });

    updateSum();
    if (selected.length > 0) {
      setMessage("ì‚¬ê°í˜• ì•ˆ ìˆ«ìì˜ í•©ì´ 10ì´ë©´ í¬ì…˜ì´ ì •ë¦¬ë©ë‹ˆë‹¤.");
    } else {
      setMessage("");
    }
  }

  function onPointerDownGrid(e) {
    if (gameOver) return;

    isDragging = true;
    clearSelectionVisual();

    const rect = gridEl.getBoundingClientRect();
    dragStartPxX = e.clientX - rect.left;
    dragStartPxY = e.clientY - rect.top;
    dragEndPxX = dragStartPxX;
    dragEndPxY = dragStartPxY;

    showDragBox(dragStartPxX, dragStartPxY, dragEndPxX, dragEndPxY);
    applyRectSelectionByPixels();

    e.preventDefault();
  }

  function onPointerMove(e) {
    if (!isDragging || gameOver) return;

    const rect = gridEl.getBoundingClientRect();
    dragEndPxX = e.clientX - rect.left;
    dragEndPxY = e.clientY - rect.top;

    showDragBox(dragStartPxX, dragStartPxY, dragEndPxX, dragEndPxY);
    applyRectSelectionByPixels();
  }

  function finishDrag() {
    if (!isDragging) return;
    isDragging = false;
    hideDragBox();

    if (selected.length === 0) {
      clearSelectionVisual();
      return;
    }

    const sum = currentSum;

    if (sum === 10 && !gameOver) {
      const removedCount = selected.length;
      score += removedCount;  // ì ìˆ˜ = ì œê±°ëœ ë¸”ë¡ ê°œìˆ˜
      scoreEl.textContent = score;
      setMessage(`ì •ë‹µ! ìš©ëŸ‰ 10ì§œë¦¬ í¬ì…˜ ì™„ì„±! (ë¸”ë¡ ${removedCount}ê°œ ì •ë¦¬) ğŸ§ª`);

      selected.forEach(c => {
        c.cleared = true;
        if (c.el) {
          c.el.classList.remove("selected");
          c.el.classList.add("cleared");
        }
      });
    } else {
      setMessage(`í•©ì´ ${sum}ì…ë‹ˆë‹¤. 10ì´ ì•„ë‹ˆì—ìš”. ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”.`);
      selected.forEach(c => {
        if (c.el && !c.cleared) {
          c.el.classList.add("highlight");
          setTimeout(() => {
            if (c.el) c.el.classList.remove("highlight");
          }, 200);
        }
      });
    }

    clearSelectionVisual();
  }

  function onPointerUp(e) {
    finishDrag();
  }

  function onPointerLeave(e) {
    finishDrag();
  }

  function showGameOverOverlay() {
    gameOver = true;
    let isNewRecord = false;
    if (score > bestScore) {
      bestScore = score;
      isNewRecord = true;
      saveBestScore();
    }

    overlayCurrentEl.textContent = `ì´ë²ˆ ì ìˆ˜: ${score}ì `;
    if (isNewRecord) {
      overlayBestEl.innerHTML =
        `ìµœê³  ê¸°ë¡ ê°±ì‹ ! <span class="badge-new">NEW</span>`;
    } else {
      overlayBestEl.textContent = `í˜„ì¬ ìµœê³  ê¸°ë¡: ${bestScore}ì `;
    }

    overlayEl.classList.remove("hidden");
  }

  function startTimer() {
    if (timerId) clearInterval(timerId);
    timeLeft = 90;
    timeEl.textContent = timeLeft;
    timeEl.classList.remove("time-danger");
    gameOver = false;

    timerId = setInterval(() => {
      timeLeft--;
      if (timeLeft < 0) timeLeft = 0;
      timeEl.textContent = timeLeft;

      if (timeLeft <= 10) {
        timeEl.classList.add("time-danger");
      }

      if (timeLeft <= 0) {
        clearInterval(timerId);
        timerId = null;
        setMessage(`ì‹œê°„ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜: ${score}ì `);
        showGameOverOverlay();
      }
    }, 1000);
  }

  function hideGameOverOverlay() {
    overlayEl.classList.add("hidden");
  }

  function hideStartOverlay() {
    startOverlayEl.classList.add("hidden");
  }

  function resetGame() {
    if (timerId) {
      clearInterval(timerId);
      timerId = null;
    }
    hideGameOverOverlay();
    hideStartOverlay();
    hideDragBox();
    score = 0;
    scoreEl.textContent = "0";
    clearSelectionVisual();
    setMessage("ì‚¬ê°í˜•ìœ¼ë¡œ ë“œë˜ê·¸í•´ì„œ í•©ì´ 10ì¸ í¬ì…˜ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”.");
    createGridData();
    renderGrid();
    startTimer();
  }

  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
  gridEl.addEventListener("pointerdown", onPointerDownGrid);
  gridEl.addEventListener("pointermove", onPointerMove);
  gridEl.addEventListener("pointerup", onPointerUp);
  gridEl.addEventListener("pointerleave", onPointerLeave);

  resetBtn.addEventListener("click", resetGame);
  overlayRestartBtn.addEventListener("click", resetGame);
  startBtn.addEventListener("click", resetGame);

  // ì´ˆê¸° ì‹¤í–‰
  loadBestScore();
  createGridData();
  renderGrid();
  setMessage("ê²Œì„ì„ ì‹œì‘í•˜ë ¤ë©´ [ê²Œì„ ì‹œì‘] ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
</script>
</body>
</html>
